
def create_rkSolver(obj_name = 'pySolver'):
    """
    bare FeaturePython with attached solver for reverse kinematic problem
    """

    obj = App.ActiveDocument.addObject('App::FeaturePython', obj_name)
    rkSolver(obj)

    # App.ActiveDocument.recompute()
    return obj

class GPinspector():
    def __init__(self, obj):
        """
        Default constructor
        """
        self.Type = 'GPinspector'
        obj.Proxy = self
        # obj.addProperty('App::PropertyString', 'Description', 'Base', 'Box description')
        obj.addProperty("App::PropertyLink", "inspectedObject", "Base",
            'The object whose subobjects real global placment values shall be retrieved')
        obj.addProperty("App::PropertyStringList", "inspectedSubobjectList", "Base",
            'List of subObjects under surveillance - autogenerated')
        obj.setEditorMode('inspectedSubobjectList', ['ReadOnly'])

    def onChanged(self, obj, prop):
        # self.execute(obj) # triggers endless recalc loop
        try:
            # prints "<App> Document.cpp(2705): Recursive calling of recompute"
            # but result looks fine
            App.ActiveDocument.recompute()
        except:
            print('App.ActiveDocument.recompute() failed')

    # def onDocumentRestored(self, obj):
        # self.execute(obj)
        # pass

    def execute(self, obj):
        """
        Called on document recompute
        """
        print('Recomputing {0:s} ({1:s})'.format(obj.Name, self.Type))
        #
        surveilland = obj.inspectedObject
        if not surveilland:
            print('no object for inspection selected')
            obj.Label=obj.Name
        else:
            obj.Label='GPinsp_' + surveilland.Label
            paramDict = sync_GPParams(obj, surveilland)
            print ('paramDict:', paramDict)
            prefix='' # valid for singleton links
            for so in paramDict.keys():
                pg_prm = paramDict[so]
                path = prefix + so  #  so.rstrip('.')
                plc = surveilland.getSubObject(path, retType = 3)
                prop = getattr(obj, pg_prm)
                print("checker: so, pg_prm , prop, path, plc:",so, pg_prm , prop, path, plc)
                if plc:
                    # direct assignment of plc does not work
                    setattr(obj, pg_prm, plc.Matrix)
